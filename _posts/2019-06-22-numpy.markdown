---
layout: post
title:  "numpy"
date:   2019-06-22 01:25:21 +0530
categories: python
tags: [numpy, "selection sort", python]
---


```python
import numpy as np
```

Numpy has four main attributes for inspection


```python
x = np.array([[2,3],[5,6]])
print(x.ndim) # number of dimensions
print(x.shape)  # length along the dimension
print(x.size) # total numbers of elements
print(x.dtype) # data type of element
```

    2
    (2, 2)
    4
    int64


Numpy use compiled functions called ufuncs(?) implemented for elementwise operation (or called vectorized). Comparing time with ufuncs vs loop:


```python
x = np.ones(10000)
y = np.ones(10000)
```


```python
%%timeit
# using ufuncs
y = x + 1
```

    11 µs ± 520 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)



```python
%%timeit
# using loop
for i in np.arange(x.size):
    y[i] = x[i] + 1
```

    8.23 ms ± 99.2 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)



```python
# np.linspace, important function
x = np.linspace(start=2,
    stop=48,
    num=50,
    endpoint=True,
    retstep=False,
    dtype=None,
    axis=0,)
x
```




    array([ 2.        ,  2.93877551,  3.87755102,  4.81632653,  5.75510204,
            6.69387755,  7.63265306,  8.57142857,  9.51020408, 10.44897959,
           11.3877551 , 12.32653061, 13.26530612, 14.20408163, 15.14285714,
           16.08163265, 17.02040816, 17.95918367, 18.89795918, 19.83673469,
           20.7755102 , 21.71428571, 22.65306122, 23.59183673, 24.53061224,
           25.46938776, 26.40816327, 27.34693878, 28.28571429, 29.2244898 ,
           30.16326531, 31.10204082, 32.04081633, 32.97959184, 33.91836735,
           34.85714286, 35.79591837, 36.73469388, 37.67346939, 38.6122449 ,
           39.55102041, 40.48979592, 41.42857143, 42.36734694, 43.30612245,
           44.24489796, 45.18367347, 46.12244898, 47.06122449, 48.        ])




```python
# numpy has lots of mathematical function but some odd function can be imported from scipy.special
from scipy import special
special.gamma([1,2,4])
```




    array([1., 1., 6.])



Output can intialized before to speed. Numpy provides convinent way to assign.


```python
x = np.zeros(100)
y = np.ones(100)
np.add(x, 1, out=y)
y
```




    array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
           1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
           1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
           1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
           1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,
           1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])




```python
# np unfucs can be called by np.add instead of +
# these functions have further methods
np.add.reduce(y)
```




    100.0




```python
x = np.array([1,2])[:,np.newaxis]
y = np.array([3,4])[np.newaxis,:]
z = np.array([5,6])
print("x:", x)
print("y:", y)
print("z:", z)
# shape
print("x shape:", x.shape) # 2 rows and 1 columns
print("y shape:", y.shape) # 1 row and 2 columns
print("z shape:", z.shape) # z is one dimensional vector
```

    x: [[1]
     [2]]
    y: [[3 4]]
    z: [5 6]
    x shape: (2, 1)
    y shape: (1, 2)
    z shape: (2,)


Broadcasting rules:

1. Shape is matched first by adding 1 to left of shape.
Here z is converted to (1,2) while adding to y
2. 1 in shape are converted to required lenth
3. Gives error if either shape fails to match


```python
print("zy:", z + y)
print('zx:', z+x)
print('zy:', x+y)
```

    zy: [[ 8 10]]
    zx: [[6 7]
     [7 8]]
    zy: [[4 5]
     [5 6]]


Some repeatedly used functions:

!= not equal to

~ not

^ xor

`and` and `or` compares the whole object so they are better suited for control flow statement. For vector use numpy `&` and `|`



## Fancy indexing


```python
# used by [] brackets
x = np.array([2,3,4,5,6,7,8,9,9,3,3,5,6])
x[[2,3]] # fetches 2 and 3 element

```




    array([4, 5])




```python
x = np.array([[2,3],[4,5]])
x[1] # second row
```




    array([4, 5])




```python
x[[0,1]] # first row and first columns
```




    array([[2, 3],
           [4, 5]])




```python
# selection sort
x = np.array([2,3,4,5,6,7,8,9,9,3,3,5,6])
for i in np.arange(x.size):
    swap = i + np.argmin(x[i:])
    tmp = x[i]
    x[i], x[swap] =  x[swap], tmp
x
```




    array([2, 3, 3, 3, 4, 5, 5, 6, 6, 7, 8, 9, 9])




```python
x = np.array([2,3,4,5,6,7,8,9,9,3,3,5,6])
print(np.sort(x)) # returns the sorted array
print(x)
x.sort() # sort in place
x # do all object method sort in place
```

    [2 3 3 3 4 5 5 6 6 7 8 9 9]
    [2 3 4 5 6 7 8 9 9 3 3 5 6]





    array([2, 3, 3, 3, 4, 5, 5, 6, 6, 7, 8, 9, 9])
